
# highload
Проектирование веб-сервиса

## 1. Тема проекта:
Стриминговый аудио сервис - https://music.yandex.ru/

## 2. Целевая аудитория сервиса:
Статистику взяла с <https://radar.yandex.ru/yandex?month=2021-01>

Месячная аудитория в среднем порядка 12 млн п/мес.

Дневная аудитория в среднем 2 млн п/мес.

Время среднее 3ч 23мин = 203 мин аудиоконтента в день.


## 3. MVP проекта:
 1 - Авторизация, регистрация. 2 - Музыка пользователя, плейлисты (популярные, дневной).  
 
 Будем рассматривать основной функционал - прослушивание музыки.
 

## 4. Выбор планируемой нагрузки:
Нагрузку на добавление песен можно не учитывать, так как она достаточно мала и незначительна по сравнению с нагрузкой, которая приходится на отдачу музыки.

Имеем, что в среднем пользователь сервиса в день слушает 203 минуты аудиоконтента. Среднее количество пользователей в день 2 миллона.
Будем считать, что сервис передает треки в максимальном качестве с битрейтом 320 kbps. Передачу среднего качества музыки возьмем равным 192 kbps.
Данные взяла из статьи <https://roem.ru/02-02-2016/218250/music-yandex-hifi/>

### Рассчет веса одной песни:
Таким образом, **минимальный вес с максимальным качеством за 1 минуту**: 320(kbps) * 60(сек) = 19200 КБит = 2400 КБайт = 2,34375 МБайта ~ 2,344 МБайта.

Возьмем среднюю величину, а именно с битрейтом 192 kbps, и будем считать, что это минимально возможный вес песни. Помимо этого, сервис сам может регулировать нагрузку и снижать битрейт при необходимости.

Получаем **минимальный вес 1 минуты**: 192(kbps) * 60(сек) = 11400 КБит = 1425 КБайт ~ 1,391 МБайта.

Так как большая часть музыки все же передается со средним качеством музыки, части песен нет в максимальном качестве, и не все пользователи слушают платную Яндекс.Музыку, то будем считать, чо у нас в сервисе в среднем 50% музыки с битрейтом 192 kbps и 50% музыки с битрейтом 320 kbps. Так же предположим, что пользователь будет слушать и ту, и другую музыку равновероятно.

Постчитаем **средний вес одной минуты песни**: (2,344 МБ + 1,391 МБ)/2 ~ 1,9 МБайт.
Одна песня весит примерно 7 МБайт.
Рассчитаем дневную нагрузку. Дневная аудитория ~2 млн пользователей. В среднем люди тратят на прослушивание музыки около 203 минут в день. Тогда дневной трафик составляет:
2 * 10^6 * 203 * 1,9 = 735 TБайт

### Рассчет объема хранилища:
Медиатека Яндекс.Музыки составляет [более 60 млн треков](https://vc.ru/media/96460-chislo-podpischikov-yandeks-muzyki-vyroslo-v-tri-raza-za-poltora-goda-i-dostiglo-3-mln "более 60 млн треков"). Будем считать, что каждая песня хранится в двух битрейтах для удобства отдачи в бесплатной и платной версиях. Таким образом, 1 минута песни с минимальным качеством весит 1,4 Мбайта, а в наилучшем качестве - 2,4 Мбайта. Получаем, что одна минута песни весит (1,4 + 2,344) = 3,744 Мбайта, тогда целая песня примерно 15 Мбайта.
Тогда минимальный объем хранилища для музыки составляет 60 * 10^6 * 15 = 859 Тбайт.

### Рассчет трафика:
**Один пользователь скачивает за день** в среднем: 203(мин) * 1,867(МБ) = 379,001 МБайт аудиоконтента.

За **один день в среднем с нашего сайта скачивается** 379,001(МБ) * 2 000 000(пользоветелй) = 758 002 000 МБайт  музыки ~ 722,887 ТБайт ~ 68,5 ГБит/с

Учтем, что при дневном пике нагрузка возрастает в 2.5 раза.

Таким образом, **в дневной пик количество пользователей** увеличивается до 2,5 x (2(млн польз.)/24)(среднее кол-во пользователей в час) ~ 208 333 пользоветеле в час.
**Нагрузка на дневной пик** составляет 379,001(МБ) * 208333(польз./час) ~ 78 958 415 МБайт в час = 75,3 ТБайт в час ~ 171,3 Гбит/с

### Рассчет количества RPS:
Выполним примерную оценку количества RPS для сервиса. За 203 минуты пользователь прослушивает примерно 51 песню (примерно 4 минуты на 1 песню), пусть за каждой песней он совершает 2 запроса в бд(загрузка песни и данных о ней). 

Если учесть, что на сервисе имеется готовый плейлист, то для реализации пользоветльского сценария, такого как выбор плейлиста и его включение, необходимо послать 3 запроса: загрузить главную страницу со списком плейлистов, загрузить данные пользователя и загрузить конкретный плейлист. Помимо этого пользователь может сменить плейлист в процессе прослушивания другого плейлиста,используя поиск, пусть переключение плейлиста происходит 3 раза за одну сессию прослушивания. Для этого необходимо еще 3 запроса: переход в меню поиска, список плейлистов, загрузка конкретного плейлиста.

Так же в процессе прослушивания у пользователя может возникнуть необходимость переключить трек. Будем считать, что за одну сессию таких запросов совершается 5 штук.


**Предполагаемая нагрузка**: 2 * 10^6 * (51 * 2 + 3 + 3 * 3) / 24 / 60 / 60 = 2639 rps

**Основные запросы для навигации по контенту:**

 1. Загрузка списка плейлистов
 За один запрос возвращается около 30 элементов списка, остальные данные подгружаются по мере необходимости. Подгрузка аналогична первому запросу за данными. За сессию пользователь совершает 3 таких запроса, тогда RPS: 2 * 10^6 * 3 / 24 / 60 / 60 = 69,4 rps
 2. Загрузка плейлиста
Загрузка плейлиста происходит за 1 запрос, за сессию пользователь  делает 3 запроса: 2 * 10^6 * 3 / 24 / 60 / 60 = 69,4 rps
 3. Поиск
Поиск выполнятся за 1 запрос. За сессию пользователь использует поиск 3 раза: 2 * 10^6 * 3 / 24 / 60 / 60 = 69,4 rps

## Логическая схема базы данных
![image](https://user-images.githubusercontent.com/49959597/118158174-1d665480-b424-11eb-8bdc-3d05a66d8ef8.png)


## Физическая схема базы данных
Необходимо денормализировать исходную схему Бд, добавив в таблицу треков, очередей и историй дополнительные поля.
![image](https://user-images.githubusercontent.com/49959597/118158813-f0667180-b424-11eb-8bea-245f24dfa469.png)

Для раздачи контента нам будет необходимо 3 датацентра. В 2 датацентрах будут находить реплики основного ДЦ

Для БД выберем сервера со следующими характеристиками: 4ТБ памяти 32 ядра 2x256Гб SSD RAID 10

Для сервися аутефикации будет использоваться:

СУБД: Tarantool (для хранения логина, пароля и никнейма)

Оценим приблизительный необходимый **объем памяти на одного пользователя**:
ID [bigint] (8 байт) full_name [text] (предположим, что среднее значение 16 символов) password [text] (предположим, что среднее значение 16 символов) email [text] (предположим, что среднее значение 16 символов)
age [char] (8 бит)

Средний объем памяти занятый под одного юзера: 8 + 16 * 3 + 1 = 57 байт

На сервер вместиться с учетом запаса в 60% :

4 * 1024^4 (байты) * 0.4 * 0.95 (коэфф заполнения) / 57 = 1 671 257 674 219 записей пользователей
Этого объема хватит для наших текущих потребностей сполна.

Предполагаемая нагрузка на всю систему бэков: 2639 rps => такую нагрузку выдержит и 1 сервер на PostreSQL (выдает 25000 rps на чтение). Но поставим 2 сервера

Партиции: БД развибается в группы по 10 000 пользователей по ID

Шардирование: Нет необходимости

СУБД: Redis (для хранения пользовательских токенов) Шардирование: Нет необходимости

Для сервисов пользовательской музыки:

СУБД: PostreSQL

Треки:
4(id) + 256(song_name) + 4(release) + 4(duration) + 4(id_artist) + 2*256(path) + 4(artist_name) + 256(album_name) = 1044 байт
80 млн в медиатеке

Альбомы: 4(id) + 256(album_name)+ 4(artist) + 4(release) = 268 байт
Среднее количество песен в музыкальном альбоме 11, тогда у нас будет примерно 7,2 млн альбомов.

Исполнители: 4(id) + 256(full_name) + 1024(description) = 1284 байт
Пусть у каждого исполнителя будет по 4 альбов, тогда у нас всего 1,8 млн исполнителей.

История прослушивания. Будем хранить треки, прослушанные пользователем за посление сутки. 4(id_user) + 4(id_music) + 4(id_album) + 256(music_name) + 256(album_name) + 4(date) + 4(time_of_listening) = 532 байт: 532 * 23 * 2 * 10^6 = 23 338 Мб

Связь многие ко многим: 3 * 4(id) = 12 байт

Итого: (1044 * 80 (треки) + 268 * 7,2 (альбомы) + 1284 * 1,8 (исполнители) + 532 * 23 (история) + 12 * (80 + 1,8 + 80)) * 10^6 = (83520 + 1929 + 12236 + 1941) * 10^6 = 92 Гб

Берем 2 сервера

В шардировании нужды нет, ко всем данным доступ одинаковый. Партицируем по ID пользователя.

## Выбор технологий

web client: JavaScrip или TypeScript. Будет использован React

Для сервисов связанных с музыкой необходимо использовать C/Cpp для получения максимальной скорости
Для сервисов входа и регистрации пользователя:
Бэкенд на Golang
Для сервисов рекомендаций и обработки пользовательской информации:
Python, а также механизмы системы рекомендации. Является наиболее логичным выбором для рекомендательной системы тк написанно много удобных бибилиотек для работы с анализом предпочтений пользовтелей и пр..
